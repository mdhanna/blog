{
  
    
        "post0": {
            "title": "Classifying Labradors with fastai",
            "content": "Although I&#39;ve been a practicing data scientist for more than three years, deep learning remained an enigma to me. I completed Andrew Ng&#39;s deep learning specialization on Coursera last year but while I came away with a deeper understanding of the mathematical underpinnings of neural networks, I could not for the life of me build one myself. . Enter fastai. With a mission to &quot;make neural nets uncool again&quot;, fastai hands you all the tools to build a deep learning model today. I&#39;ve been working my way through their MOOC, Practical Deep Learning for Coders, one week at a time and reading the corresponding chapters in the book. . I really appreciate how the authors jump right in and ask you to get your hands dirty by building a model using their highly abstracted library (also called fastai). An education in the technical sciences too often starts with the nitty gritty fundamentals and abstruse theories and then works its way up to real-life applications. By this time, of course, most of the students have thrown their hands up in despair and dropped out of the program. The way fastai approaches teaching deep learning is to empower its students right off the bat with the ability to create a working model and then to ask you to look under the hood to understand how it operates and how we might troubleshoot or fine-tune our performance. . A brief introduction to Labradors . To follow along with the course, I decided to create a labrador retriever classifier. I have an American lab named Sydney, and I thought the differences between English and American labs might pose a bit of a challenge to a convolutional neural net since the physical variation between the two types of dog can often be subtle. . Some history . At the beginning of the 20th century, all labs looked similar to American labs. They were working dogs and needed to be agile and athletic. Around the 1940&#39;s, dog shows came popular, and breeders began selecting labrador retrievers based on appearance, eventually resulting in what we call the English lab. English labs in England are actually called &quot;show&quot; or &quot;bench&quot; labs, while American labs over the pond are referred to as working Labradors. . Nowadays, English labs are more commonly kept as pets while American labs are still popular with hunters and outdoorsmen. . Physical differences . English labs tend to be shorter in height and wider in girth. They have shorter snouts and thicker coats. American labs by contrast are taller and thinner with a longer snout. . English American These differences may not be stark as both are still Labrador Retrievers and are not bred to a standard. . Gathering data . First we need images of both American and English labs on which to train our model. The fastai course leverages the Bing Image Search API through MS Azure. The code below shows how I downloaded 150 images each of English and American labrador retrievers and stored them in respective directories. . path = Path(&#39;/storage/dogs&#39;) subscription_key = &quot;&quot; # key obtained through MS Azure search_url = &quot;https://api.bing.microsoft.com/v7.0/images/search&quot; headers = {&quot;Ocp-Apim-Subscription-Key&quot; : subscription_key} names = [&#39;english&#39;, &#39;american&#39;] if not path.exists(): path.mkdir() for o in names: dest = (path/o) dest.mkdir(exist_ok=True) params = { &quot;q&quot;: &#39;{} labrador retriever&#39;.format(o), &quot;license&quot;: &quot;public&quot;, &quot;imageType&quot;: &quot;photo&quot;, &quot;count&quot;:&quot;150&quot; } response = requests.get(search_url, headers=headers, params=params) response.raise_for_status() search_results = response.json() img_urls = [img[&#39;contentUrl&#39;] for img in search_results[&quot;value&quot;]] download_images(dest, urls=img_urls) . Let&#39;s check if any of these files are corrupt. . fns_updated = get_image_files(path) failed = verify_images(fns) failed . (#1) [Path(&#39;/storage/dogs/english/00000133.svg&#39;)] . We&#39;ll remove that corrupt file from our images. . failed.map(Path.unlink); . First model attempt . I create a function to process the data using a fastai class called DataBlock, which does the following: . Defines the independent data as an ImageBlock and the dependent data as a CategoryBlock | Retrieves the data using a fastai function get_image_files from a given path | Splits the data randomly into a 20% validation set and 80% training set | Attaches the directory name (&quot;english&quot;, &quot;american&quot;) as the image labels | Crops the images to a uniform 224 pixels by randomly selecting certain 224 pixel areas of each image, ensuring a minimum of 50% of the image is included in the crop. This random cropping repeats for each epoch to capture different pieces of the image. | . def process_dog_data(path): dogs = DataBlock( blocks=(ImageBlock, CategoryBlock), get_items=get_image_files, splitter=RandomSplitter(valid_pct=0.2, seed=44), get_y=parent_label, item_tfms=RandomResizedCrop(224, min_scale=0.5) ) return dogs.dataloaders() . The item transformation (RandomResizedCrop) is an important design consideration. We want to use as much of the image as possible while ensuring a uniform size for processing. But in the process of naive cropping, we may omitting pieces of the image that are important for classification (ex. the dog&#39;s snout). Padding the image may help but wastes computation for the model and decreases resolution on the useful parts of the image. . Another approach of resizing the image (instead of cropping) results in distortions, which is especially problematic for our use case as the main differences between English and American labs is in their proportions. Therefore, we settle on the random cropping approach as a compromise. This strategy also acts as a data augmentation technique by providing different &quot;views&quot; of the same dog to the model. . Now we &quot;fine-tine&quot; ResNet-18, which replaces the last layer of the original ResNet-18 with a new random head and uses one epoch to fit this new model on our data. Then we fit this new model for the number of epochs requested (in our case, 4), updating the weights of the later layers faster than the earlier ones. . dls = process_dog_data(path) learn = cnn_learner(dls, resnet18, metrics=error_rate) learn.fine_tune(4) . epoch train_loss valid_loss error_rate time . 0 | 1.392489 | 0.944025 | 0.389831 | 00:15 | . epoch train_loss valid_loss error_rate time . 0 | 1.134894 | 0.818585 | 0.305085 | 00:15 | . 1 | 1.009688 | 0.807327 | 0.322034 | 00:15 | . 2 | 0.898921 | 0.833640 | 0.338983 | 00:15 | . 3 | 0.781876 | 0.854603 | 0.372881 | 00:15 | . These numbers are not exactly ideal. While training and validation loss mainly decrease, our error rate is actually increasing. . interp = ClassificationInterpretation.from_learner(learn) interp.plot_confusion_matrix(figsize=(5,5)) . The confusion matrix shows poor performance, especially on American labs. We can take a closer look at our data using fastai&#39;s ImageClassifierCleaner tool, which displays the images with the highest loss for both training and validation sets. We can then decide whether to delete these images or move them between classes. . cleaner = ImageClassifierCleaner(learn) cleaner . We definitely have a data quality problem here as we can see that the fifth photo from the left is a German shepherd and the fourth photo (and possibly the second) is a golden retriever. . We can tag these kinds of images for removal and retrain our model. . After data cleaning . Now I&#39;ve gone through and removed 49 images from the original 300 that were not the correct classifications of American or English labs. Let&#39;s see how this culling has affected performance. . dls = process_dog_data() learn = cnn_learner(dls, resnet18, metrics=error_rate) learn.fine_tune(4) . epoch train_loss valid_loss error_rate time . 0 | 1.255060 | 0.726968 | 0.380000 | 00:14 | . epoch train_loss valid_loss error_rate time . 0 | 0.826457 | 0.670593 | 0.380000 | 00:14 | . 1 | 0.797378 | 0.744757 | 0.320000 | 00:15 | . 2 | 0.723976 | 0.809631 | 0.260000 | 00:15 | . 3 | 0.660038 | 0.849696 | 0.280000 | 00:13 | . Already we see improvement in that our error rate is finally decreasing for each epoch, although our validation loss increases. . interp = ClassificationInterpretation.from_learner(learn) interp.plot_confusion_matrix(figsize=(5,5)) . This confusion matrix shows much better classification for both American and English labs. . Now let&#39;s see how this model performs on a photo of my own dog. . Using the Model for Inference . I&#39;ll upload a photo of my dog Sydney. . btn_upload = widgets.FileUpload() btn_upload . img = PILImage.create(btn_upload.data[-1]) out_pl = widgets.Output() out_pl.clear_output() with out_pl: display(img.rotate(270).to_thumb(128,128)) out_pl . This picture shows her elongated snout and sleeker body, trademarks of an American lab. . pred,pred_idx,probs = learn.predict(img) lbl_pred = widgets.Label() lbl_pred.value = f&#39;Prediction: {pred}; Probability: {probs[pred_idx]:.04f}&#39; lbl_pred . Label(value=&#39;Prediction: american; Probability: 0.9284&#39;) . The model got it right! . Take-aways . If I were serious about improving this model, I&#39;d manually look through all these images to confirm that they contain either English or American labs. Based on the images shown by the cleaner tool, the Bing Image Search API does not return many relevant results and needs to be supervised closely. . I was definitely surprised to achieve such decent performance on so few images. I had always been under the impression that neural networks required a lot of data to avoid overfitting. Granted, this may still be the case here based on the growing validatoin loss but I&#39;m looking forward to learning more about this aspect later in the course. . While I appreciate that the fastai library is easy-to-use and ideal for deep learning beginners, I found some of the functionality too abstracted at times and difficult to modify or troubleshoot. I suspect that subsequent chapters will help me become more familiar with the library and feel more comfortable making adjustments but for someone used to working more with the nuts and bolts within Python, this kind of development felt like a loss of control. . I&#39;m extremely interested to understand how the model arrives at its classifications. Is the model picking up on the same attributes that humans use to classify these dogs (i.e. snouts, body shapes)? While I&#39;m familiar with the SHAP library and its ability to highlight CNN feature importances within images, Chapter 18 of the book introduces &quot;class activation maps&quot; or CAM&#39;s to accomplish the same goal. I&#39;ll revisit this model once I&#39;ve made further progress in the course to apply some of these explanability techniques to our Labrador classifier and understand what makes it tick. .",
            "url": "https://mdhanna.github.io/mels_blog/2020/12/10/dog-classifier.html",
            "relUrl": "/2020/12/10/dog-classifier.html",
            "date": " • Dec 10, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Being Radically Candid amidst the Chaos of 2020",
            "content": "It’d be an understatement to say that so far, 2020 has been a tough year for nearly everyone. From a global pandemic sickening millions of people to civil unrest rocking the United States and beyond, the world seems to have turned upside down. . If you’ve found yourself in a management position during this chaos, you may be wondering how best to navigate the shift of your company to remote work, the mental health of your team, and the need to address systemic racism in your organization. . Applying the concepts behind “Radical Candor” can help you tackle these issues head-on. And anyone—from CEO’s to individual team members—can start using these lessons today to begin effecting change. . What is Radical Candor? . Radical Candor is a 2017 book and management philosophy from Kim Scott, a former manager at Apple and Google. We can sum it up with the following: . Managers should care personally and challenge directly. . Fleshing this out a bit more, Scott created a matrix to show how managers might fall short on either of these goals. . Credit to radicalcandor.com Obnoxious Aggression: A manager who isn’t afraid to challenge his/her employees but has made no effort to show that he/she cares about them as people or is invested in their success. . | Ruinous Empathy: A manager who shies away from providing “uncomfortable” criticism out of fear he/she may hurt their employee’s feelings. The vast majority of managers fall into this category, and this is definitely where I naturally land. . | Manipulative Insincerity: A manager who doesn’t bother to give any direct feedback or show interest in his/her employees’ careers. In other words, the worst kind of manager you could get. . | Radical Candor: A manager who recognizes that giving direct feedback in a respectful manner is the best way to help his/her employees succeed and who takes the time to demonstrate personal and professional investment in them. . | . To sum up, promoting a trusting environment where team members aren’t afraid to challenge each other or their manager is the quickest way to organizational success. I can’t imagine how much time and productivity we lose by withholding from someone the feedback they desperately need if they want to improve their performance at work (or anywhere!). . Compound Interest of Continuous Feedback . Scott also emphasizes the importance of real-time feedback. You might typically bottle up all your feedback for Employee Eric throughout the week and then unleash it on him during your regularly scheduled one-on-one. This can backfire for two reasons. . Sense of Whiplash: The situation for which you’re giving Eric this feedback—maybe he presented a sloppy demo to marketing on Monday and couldn’t answer any follow-up questions from the team—is now far in the past. Eric might have thought he knocked that presentation out of the park, and he internalized that view for several days before you dashed cold water all over it. . | Repeat Offender: Even worse, Eric might have already given another presentation in the meantime with the same poor quality and lackluster results. . | . While these two possibilities should be reason enough to start giving feedback immediately whenever possible, I like to think about real-time feedback as analogous to compound interest. Any armchair investor knows that continuously compounded interest grows at a much faster rate than annual or “simple” interest. . Credit to fool.com Feedback works the same way. If we frequently give small amounts of both positive and negative feedback, the recipient will compound their growth accordingly. . Radical Candor Today . Ok, this all sounds like a great way to run a company in normal times. But these are not normal times. What lessons can we learn for today? . Caring Personally . In typical circumstances, showing that you care personally about your employees or team members might not be that simple. Some people don’t like to discuss their personal lives at work or make small talk, especially introverts. And building trust organically takes time. . But today, checking in on the personal lives of your co-workers and especially your direct reports isn’t just sanctioned—it’s expected. . When we first moved to WFH, we needed to understand how this sudden shift was affecting those around us in the new virtual workplace. . Are they feeling isolated/burnt-out/unmotivated? . | Do they have kids home from school which affect what hours they can be online? . | Are they caring for elderly relatives or neighbors that might add to whatever stress they’re already feeling? . | . These conversations started to crack open the door to discuss feelings and invite vulnerability as the line between personal and professional started to blur. . The riots incited by the death of George Floyd and his death itself also warranted checking in with our colleagues. . How are they coping with the sense of unrest roiling our country? . | How are they feeling in general given current events? . | Has their neighborhood been looted or burned? . | Are they safe? . | . These last questions, especially, are not ones I ever expected to ask in my role as a manager. And while I hope these circumstances will never be repeated, I am grateful that this situation has destigmatized discussing our personal emotions at work and has given me the opportunity to show that I care personally about my team as human beings. . Confronting Racism . Our current crisis also necessitates that we act along the other axis above—challenging directly. . I admit that I fell into the contingent of white people who put our heads in the sand by believing that by simply being “not racist”, we had overcome ingrained biases and systemic prejudice in this country. . The death of George Floyd and the protests sweeping the country were a long overdue wake-up call, and like many of my peers, I took the time to try and educate myself. I’ve been reading “How to Be an Anti-Racist” by Ibram X. Kendi, which has been eye-opening. I’m ashamed that I wasn’t aware of much of the historical context around concepts of race and hadn’t realized how claiming to be “colorblind” actually hurt communities of color by turning a blind eye to racist policies. . Kendi’s proposed antidote is that we become actively anti-racist. We must constantly evaluate our beliefs, actions, and words for unconscious bias. Yes, that sounds exhausting, and it is. But people of color have been exhausted for centuries—from slavery, from blatant discrimination, from the possibility of being shot by the police—so much so that it has taken a toll on their physical and mental health. . And we must adopt this anti-racist attitude in the workplace, as well, by challenging directly. Kim Scott herself provided an example of unconscious racism embedded in the first edition of her book in a recent blog post. The book suggested using a stuffed monkey called “Whoops the Monkey” as a prop in the office to encourage team members to discuss their mistakes. As a white woman, Scott did not realize that being called a monkey is a common denigration targeted at black people, and bringing this symbol into the office, especially as a representation of mistakes, was inappropriate. . Likely she would never have known had not someone spoken up. Only by directly challenging those we see engaging in acts of racism, even unconsciously, can we start to affect real change in mindsets, language, and policies. . Conclusion . Radical Candor offers an actionable framework for managers (or anyone!) to create an open environment where direct feedback is delivered promptly and where empathy establishes a relationship of trust. These aspirations also have immediate applications to the world of 2020—by engaging with our co-workers’ personal needs amidst continuing stress and by directly confronting racial attitudes and policies in the workplace. .",
            "url": "https://mdhanna.github.io/mels_blog/management/2020/06/29/being-radically-candid-amidst-the-chaos-of-2020.html",
            "relUrl": "/management/2020/06/29/being-radically-candid-amidst-the-chaos-of-2020.html",
            "date": " • Jun 29, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Applying DAG's to Causal Models",
            "content": "I’ve been reading “The Book of Why” by Judea Pearl over the past few weeks, which has really helped formalize my intuition of causation. However, the book would be much better if Pearl left out any sentences written in the first-person as he has an annoying tendency to style himself as a messiah proclaiming the enlightened concepts of Causation to all the lowly statisticians still stuck on Correlation. . If we can look past his self-aggrandizing remarks, “The Book of Why” applies causal models to examples from the surgeon general’s committee on smoking in the 1960’s to the Monty Hall paradox. By reducing these multi-faceted problems down to a causal representation, we can finally put our finger on contributing factors or “causes” and control for them (if possible) to isolate the effect we are attempting to discover. . Perhaps the biggest takeaway for me from this book is the need to understand the data generation process when working with a dataset. This might sound like a no-brainer but too often, data scientists are so eager to jump in to the big shiny ball pit of a new dataset that they don’t stop to think about what this data actually represents. . Data scientist with a new dataset By including the process by which the data was generated in these causal models, we can augment our own mental model and unlock the true relationships behind the variables of interest. . So what’s a DAG? . Directly acyclic graphs (DAG’s) are a visual representation of a causal model. Here’s a simple one: . . You were late for work because you had to change your car’s tire because it was flat. Of course, we could add on much more than this (why was it flat?) but you get the idea. . Junction Types . Let’s explore what we can do with DAG’s through different junction types. . Chain . This is the simplest DAG and is represented in the example above. A generalized representation below shows that A is a cause of B, which is itself a cause of C. . . Collider . Now we have two causes for C. Both A and B affect the outcome C. . . Conditioning on C will reveal a non-causal, negative correlation between A &amp; B. This correlation is called collider bias. . We can understand this effect in crude mathematical terms. If A + B = C and we hold C constant, then we must increase A by the same amount we decrease B. . Additionally, this phenomenon is sometimes also called the “explain-away effect” because C “explains away” the correlation between A and B. . Note that the collider bias may be positive in cases when contributions from both A and B are necessary to affect C. . An example of a collider relationship would be the age-old nature vs. nurture question. Someone’s personality (C) is a product of both their upbringing (A) and the genes (B). . Fork . In the case of a fork, A affects both B and C. . . Without conditioning on A, there exists a spurious (non-causal) correlation between B &amp; C. A classic example of a spurious correlation is the relationship between crime (B) and ice cream sales (C). When you plot these two values over time, they appear to increase and decrease together, suggesting some kind of causality. Does ice cream cause people to commit crime? . Of course, this relationship can be explained by adding in temperature (A). Warmer weather causes people to leave their homes more often, leading to more crime (B). People also crave ice cream cones (C) on hot days. . Node Types . Mediators . A mediator is the node that “mediates” or transmits a causal effect from one node to another. . Again using the example below, B mediates the causal effect of A onto C. . . Confounders . Harking back to the crime-and-ice-cream example, temperature is the confounder node as it “confounds” the relationship between ice cream sales and crime. . . If we control for the confounder (A), we can isolate the relationship between C and B, if one exists. This is a key concept for experimental design. . Correcting for Confounding . Let’s spend some more time on this subject. Pearl’s assertion is that if we control for all confounders, we should be able to isolate the relationship between the variables of interest and therefore prove causation, instead of mere correlation. . Pearl defines confounding more broadly as any relationship that leads to $P(Y vert do(X)) neq P(Y vert X)$, where the $do$ operator implies an action. In other words, if there is a difference between the probability of an outcome $Y$ given $X$ and the probability of $Y$ given $X$ in a perfect world in which we were able to change $X$ and only $X$, then confounding is afoot. . Four Rules of Information Flow . Pearl has 4 rules for controlling the flow of information through a DAG. . In a chain (A → B → C), B carries information from A to C. Therefore, controlling for B prevents information about A from reaching C and vice versa. . | In a fork (A ← B → C), B is the only known common source of information between both A and C. Therefore, controlling for B prevents information about A from reaching C and vice versa. . | In a collider (A → B ← C), controlling for B “opens up” the pipe between A and C due to the explain-away effect. . | Controlling for descendants of a variable will partially control for the variable itself. Therefore, controlling the descendant of a mediator partially closes the pipe, and controlling for the descendant of a collider partially opens the pipe. . | Back-door criterion . We can use these causal models as represented by DAG’s to determine how exactly we should remove this confounding from our study. . If we are interested in understanding the relationship between only X and Y, we must identify and dispatch any confounding back-door paths, where a back-door path is any path from X to Y that starts with an arrow into X. . Pearl’s Games . Pearl devises a series of games that involve increasingly complicated DAG’s where the objective is to “deconfound” the path from X to Y. This is achieved by blocking every non-causal path while leaving all causal paths intact. . In other words, we need to identify and block all back-door paths while ensuring that any variable Z on a back-door path is not a descendant of X via a causal path to Y. . Let’s go through some examples, using the numbered games from the book. . Game 2 . . We need to determine which variables (if any) of A, B, C, D, or E need to be controlled in order to deconfound the path from X to Y. . There is one back-door path: X ← A → B ← D → E → Y. This path is blocked by the collider at B from the third rule of information flow. . Therefore, there is no need to control any of these variables! . Game 5 . . This one’s a bit more interesting. We have two back-door paths: . X ← A → B ← C → Y | X ← B ← C → Y | The first back-door path is blocked by a collider at B so there is no need to control any variables due to this relationship. . The second path, however, represents a non-causal path between X and Y. We need to control for either B or C. . But watch out! If we control for B, we fall into the condition outlined by Pearl’s third rule above, where we’ve controlled for a collider and thus opened up the first back-door path in this diagram. . Therefore, if we control for B, we will then have to control for A or C as well. However, we can also control for only C initially and avoid the collider bias altogether. . Conclusion . DAG’s can be an informative way to organize our mental models around causal relationships. Keeping in mind Pearl’s Four Rules of Information Flow, we can identify confounding variables that cloud the true relationship between the variables under study. . Bringing this home for data scientists, when we include the data generation process as a variable in a DAG, we remove much of the mystery surrounding such pitfalls as Simpson’s Paradox. We’re able to think more like informed humans and less like data-crunching machines—an ability we should all be striving for in our increasingly AI-driven world. .",
            "url": "https://mdhanna.github.io/mels_blog/things%20i'm%20reading/2020/06/24/applying-dags-to-causal-models.html",
            "relUrl": "/things%20i'm%20reading/2020/06/24/applying-dags-to-causal-models.html",
            "date": " • Jun 24, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "What is an ROC curve?",
            "content": "Precision and recall aren’t the only ways to quantify our performance when developing a classifier. . Plotting a Receiver Operating Characteristic (ROC) curve is another useful tool to help us quickly determine how well the classifier performs and visualize any trade-offs we might be making as we attempt to balance Type I and Type II error rates. . The basics . Let’s jump right in. Here’s an ROC curve for a model that predicts credit card default (where a positive is considered to be a default). . . Axes . The x-axis represents the False Positive Rate (FPR) or the probability of a false alarm. This can be calculated through: . . $FPR = frac{false positives}{false positives + true negatives}$ . . Put another way, FPR represents the fraction of incorrectly classified negatives (in this case, accounts that did not default but for which our model predicted would default) within the total population of negatives (all accounts that did not default). . The y-axis shows the True Positive Rate (TPR), which is equivalent to the recall. . Recall is just class-specific accuracy or: . . $recall = frac{true positives}{true positives + false negatives} $ . . Again, in the context of our example, this is the fraction of accounts that did default and for which our model predicted they would within the total population of accounts that did default. . The diagonal . The red dashed line dividing the plot represents random performance. When the FPR matches the TPR, we might as well be guessing–you’re right as often as you’re wrong. . If your curve falls to the left of the diagonal, the model is performing better than random because your true positive rate exceeds your false positive rate. Likewise, a curve to the right of the diagonal indicates some systemic error in your model, causing it to perform worse than random. . The curve . Now that we’ve established the space in which we’re working, we can best understand how to determine the ROC curve above. . The ROC visualizes the trade-offs between the FPR and the TPR when we adjust the threshold by which the classifier makes its determination. . For example, our model could determine a credit default using a probability threshold of 0.25. If the model’s probability of default is 0.32, we would return “default”. If the probability is 0.19, we could return “no default”. . . This is illustrated in the ROC plot above. The FPR and TPR for a threshold of 0.25 is represented by the black dot on the ROC curve. Our TPR is roughly 0.7 and our FPR is around 0.45. . Now, let’s lower the threshold to 0.15. . . We move further up the curve, increasing our TPR to nearly 0.9 but also increasing our FPR to about 0.75. . This illustrates the principle that as we decrease our decision threshold, we move to the right and upwards along the curve because we are simply classifying more observations overall as positives. Therefore, TPR increases as we capture more of those true positives but at the same time, our probability of false alarm also goes up as we become less strict with our requirement to classify a positive. . Choosing a threshold . This observation begs the question–what would be the optimal threshold to choose? . Of course, this will likely depend on model-specific considerations. For example, what is the cost of a false positive? If it’s relatively low, we might as well increase our TPR at the expense of an increased FPR as well. . However, if we’d like to try and balance these two competing metrics, we can choose the point along the curve that is closest to the top-left corner of the plot. This could be considered the apex of the curve, as shown below. . . The apex can be found by determining where on the curve we find a maximum difference between TPR and FPR. In our case, this occurs at a threshold of 0.29 to return a TPR of nearly 0.6 and a FPR of about 0.36. . AUC . Perhaps the most widely used application of an ROC curve is to calculate the area underneath it. This is called AUC or “Area Under Curve”. . The area in gray below represents the AUC. . . Our AUC for this model is 0.65. A random model would produce an AUC of 0.5 so we are doing better than guessing! . An ideal model would have an ROC curve that hugs the axes with an apex close to the upper-left corner, resulting in an AUC of nearly 1.0. Therefore, AUC is a way to quantify the ability of the model to maximize TPR while minimizing FPR, no matter the threshold chosen. .",
            "url": "https://mdhanna.github.io/mels_blog/data%20science%20basics/2020/06/10/what-is-an-roc-curve.html",
            "relUrl": "/data%20science%20basics/2020/06/10/what-is-an-roc-curve.html",
            "date": " • Jun 10, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Precision vs. recall",
            "content": "Congrats! You’ve built a binary classifier that you’re convinced is totally awesome. . But how do you quantify just how awesome this model is? And more specifically, how do you communicate this model’s level of awesomeness to your manager/product owner/stakeholder/random-person-on-the-street? . This is where performance metrics such as precision and recall come into play, and we’ll attempt to explain the intuition around these in addition to their definitions. . What is the positive class? . If you’ve built a binary classifier, perhaps the first step in determining your performance metric is to select a “positive” class. This is easy in some instances (ex. coronavirus test result) and less so in others (ex. determining if your pet is either a cat or a chinchilla). But establishing these definitions early (and stating them explicitly) will save a lot of confusion down the road. . False negatives vs. true positives . Something I struggled with initially was what exactly did we mean by a “false negative”? Was it a true negative that we classified incorrectly? Or did the model return an incorrect (and therefore false) prediction of negative? In other words, from whose perspective do we consider this classification false? . The answer is the latter definition above. The table below sums this up. . . Confusion matrix . Once you’ve established your false positives and false negatives, you can display them in a confusion matrix that looks very similar to the table above. . Here is an example for a classifier that attempts to determine if shoplifting is taking place (where we define a shoplifting incident as a positive). Let’s say for example, this model takes video footage from a store surveillance system and looks for certain features (ex. a customer picking up an item and hiding it under his/her shirt) that would indicate shoplifting. . The confusion matrix shows the number of observations for each class and the corresponding predictions from the model. . From the matrix above, we can see that our classifier is rather paranoid and often mistakes normal behavior for shoplifting. . Accuracy . Now we can start to sum up the classifier’s performance using a single value, such as the accuracy, which represents the fraction of correct predictions out of the total. In the shoplifting example, the accuracy is shown by the following: . . $accuracy = frac{ text{ true positives} + text{ true negatives}}{ text{ total classified}} = frac{40+ 107}{40+ 107+ 345 + 8} = 0.294$ . Unfortunately, this model is performing far worse than random. . WARNING: Note that accuracy is a misleading metric in this case due to unbalanced class sizes. In other words, because we have so few true shoplifting incidences compared to cases of normal behavior, we can easily achieve an accuracy of 0.904 by returning a prediction of “normal” every time. But no one would consider such a classifier to be truly “accurate”. . Precision and Recall . I mentioned earlier that our classifier tends to overpredict shoplifting–how can we incorporate this tendency into a performance metric? . This is where precision and recall come into play. These metrics are class-specific, which means that we must specify a value for both precision and recall for each class returned by the model. . Precision . Precision is the answer to the question: out of the total predictions for a certain class returned by the model, how many were actually correct? For example, the precision for the shoplifting class is: . . $precision = frac{TP}{TP + FP}$ . . $precision_{shoplifting} = frac{ text{ true shoplifting}}{ text{ total predicted shoplifting}} = frac{40}{40+345} = 0.104$ . . Similarly, for the normal behavior: . . $precision_{normal} = frac{ text{ true normal}}{ text{ total predicted normal}} = frac{107}{107+8} = 0.930$ . . In other words, the model’s predictions for normal behavior were correct 93% of the time, while its predictions for shoplifting were correct only 10% of the time. Yikes. . Recall . I like to think of recall as a class-specific accuracy. How many of the model’s predictions for a certain class were actually correct? . $recall = frac{TP}{TP + FN}$ . . $recall_{shoplifting} = frac{ text{ true shoplifting}}{ text{ total actual shoplifting}} = frac{40}{40+8} = 0.833$ . . $recall_{normal} = frac{ text{ true normal}}{ text{ total actual normal}} = frac{107}{107+345} = 0.237$ . . The model correctly identified 83% of the actual shoplifting incidents. . And here we see the trade-off often inherent in precision and recall. The model correctly predicted a good majority (83%) of the actual shoplifting incidents, but at the expense of also erroneously predicting many truly normal behaviors as shoplifting too (nearly 90% of the predicted shoplifting incidents). . This ties into Type I and Type II errors, where a type I error is a false positive (normal behavior incorrectly classified as shoplifting) and a type II error is a false negative (shoplifting incorrectly classified as normal behavior). . For our situation, this boils down to asking if you would rather have the police called on an innocent customer (type I) or lose merchandise to unchecked shoplifters (type II)? Understanding the costs of type I and type II errors helps to weigh whether you’d like to improve either recall or precision. Often, it’s difficult to do both simultaneously. . F1-Score . However, if you’d like to tie up both precision and recall into one single metric to hand over to your manager/product owner/stakeholder, then the F1-score (sometimes called F-measure) is for you! . This is simply the harmonic mean of the precision and recall for a given class, shown below. . . $F1 = 2 * frac{precision * recall}{precision + recall}$ . . An F1-score of 1 indicates perfect precision and recall. . If you’d like to place more importance on recall over precision, you can introduce a $ beta$ term (set $ beta$ to a value less than 1 to place more emphasis of precision instead of recall). . . $F_{ beta} = (1 + beta^2) * frac{precision * recall}{( beta^2 * precision) + recall}$ . .",
            "url": "https://mdhanna.github.io/mels_blog/data%20science%20basics/2020/05/31/precision-vs-recall.html",
            "relUrl": "/data%20science%20basics/2020/05/31/precision-vs-recall.html",
            "date": " • May 31, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://mdhanna.github.io/mels_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://mdhanna.github.io/mels_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}